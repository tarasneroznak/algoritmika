a) Пусть имеется датасет, в котором каждая строка имеет вид <timestamp, data>. 
   Строки помещались в датасет в порядке timestamp, но из-за редких сбоев строка с большим
   timestamp могла быть помещена раньше, чем строка с меньшим timestamp. 
   Аналитики провели исследование и выяснили, 
   что в датасете размером один миллион строк присутствует от 5 до 10 инверсий.
   От вас требуется предоставить алгоритм, который исправляет инверсии в датасете размера миллион строк.
   Какой алгоритм вы выберете и почему? Инверсия массива — это пара элементов, которые расположены «вне своего естественного порядка». 
   Это означает, что элемент, который в массиве встречается ранее, больше, чем тот, который встречается позже

напевно найкращим варіантом буде лінійно пройти по дата сету і свопати елемент поки він меньший
якщо взяти сортування то в складність буде n log n
також, наприклад, якщо шукати бінарним пошуком то це дасть приросту так як місце для вставки теж потрібно знайти тому складність буде n log n

тому найкращим варіантом буде - лінійно
або наприклад можливо застосувати техніку TwoPointer та йти з двох сторін датасету до центру (не впевнений не тестував)

1, data1
2, data1
3, data1
5, data1 - bad
4, data1
7, data1 - bad
6, data1
9, data1 - bad
8, data1

def resolve_collision(data):
   for i in range(len(data) - 1):
      if (data[i] > data[i + 1]):
         data[i], data[i + 1] = data[i + 1], data[i]


variant 2

за лінію не вдалось реалізувати перестановку
тому вибір падає на звичайне сортування через алгоритм quick sort two pointer pivot
при реалізації задачі (https://contest.yandex.ru/contest/27883/problems/B/)
цей алгоритм виявився найкращим для сортування рівних та +/- відсортованих даних
і виконує меньшу кількість свапів

function quickSort_tp(A) {
   function partition(left, right) {
      let pivot = A[parseInt((right + left) / 2)];
      let l = left;
      let r = right;

      while (l <= r) {
         while (A[l] < pivot) l++;
         while (A[r] > pivot) r--;

         if (l <= r) {
            [A[l], A[r]] = [A[r], A[l]];
            l++;
            r--;
         }
      }

      return l;
   }

   function qs(left, right) {
      while (right > left) {
         let p = partition(left, right);
         qs(p, right);
         right = p - 1;
      }
   }

   return qs(0, A.length - 1);
}